

class 글자하나{
    constructor(글자별자소배열, 글자인덱스) {
        
        this.글자별자소배열 = 글자별자소배열;
        this.글자인덱스 = 글자인덱스;
    }

    //객체 데이터 초기화  
    //입력데이터로 객체데이터를 업데이트한다.
    init() {
        let 글자별자소배열 = this.글자별자소배열;

        for (let i = 0; i < 글자별자소배열.length; i++){
            let 자소이름 = 글자별자소배열[i] + '';
            let 자소배열 = 자소모델설정(자소이름);
            let 글자속자소인덱스 = i;
            let 객체자소 = new 자소하나(자소배열, this.글자인덱스, 글자속자소인덱스, 자소이름); 
            
            자소하나배열.push(객체자소);
        }
    }

}



// 캐릭터 객체
class 자소하나{
    constructor(글자하나자소배열, 글자인덱스, 글자속자소인덱스, 자소이름) {
        this.글자하나자소배열 = 글자하나자소배열;
        this.글자인덱스 = 글자인덱스;
        this.글자속자소인덱스 = 글자속자소인덱스;
        this.자소이름 = 자소이름;
        this.자소하나점배열;

    }

    init() {
        let 글자속자소인덱스 = this.글자속자소인덱스;
        let 글자하나자소배열 = this.글자하나자소배열;
        console.log(글자하나자소배열);
        

        let 글자이동점 = 글자이동점얻기(this.글자인덱스);
        let 자소이동점 = 자소이동점얻기(this.자소이름, 글자속자소인덱스, 글자이동점);
        let 자소타입 = 자소타입얻기(this.자소이름, 글자속자소인덱스, 글자이동점);

        

        for (let i = 0; i < 글자하나자소배열.length; i++){
            //글자인덱스 바탕으로 글자이동점, 자소이동점을 계산하여 캐릭터 객체를 생성해준다.
            
            //캐릭터 객체 생성
            let 캐릭터 = new 캐릭터하나(글자하나자소배열[i], 글자이동점, 자소이동점, 자소타입);
            캐릭터배열.push(캐릭터);
        }
    }
}




class 캐릭터하나 {
    constructor(시작점, 글자이동점, 자소이동점, 자소타입) {
        this.시작점 = 시작점;
        this.글자이동점 = 글자이동점;
        this.자소이동점 = 자소이동점;
        this.자소타입 = 자소타입;
        
        this.g = 0;
        // 개선필요
        this.닿자위치 = { x: 글자이동점.x + this.g, y: 글자이동점.y + m1 },
        this.종적모음위치 = { x: 글자이동점.x + m2, y: 글자이동점.y },
        this.횡적모음위치 = { x: 글자이동점.x, y: 글자이동점.y + m3 },
        this.받침위치 = { x: 글자이동점.x + this.g, y: 글자이동점.y + m4 };
        
    }
    
    
    그리기() {
       
        
        this.가이드선();

        let 글자단위이동점 = this.글자이동점;
        let 자소단위이동점;
        
        if (this.자소타입 === "닿자") { 자소단위이동점 = this.닿자위치; }
        else if (this.자소타입 === "받침") { 자소단위이동점 = this.받침위치; }
        else if (this.자소타입 === "횡적모음") { 자소단위이동점 = this.횡적모음위치; }
        else if (this.자소타입 === "종적모음") { 자소단위이동점 = this.종적모음위치; }
        
        push();
        translate(글자단위이동점.x, 글자단위이동점.y);
        translate(자소단위이동점.x, 자소단위이동점.y);
        ellipse(this.시작점.x, this.시작점.y, 10, 10);
        pop();
        
    }

    가이드선() {
        push();
        stroke(234);
        strokeWeight(.5);
        line(100, 0, 100, 500);
        line(200, 0, 200, 500);
        line(300, 0, 300, 500);
        line(400, 0, 400, 500);
        line(500, 0, 500, 500);
        line(600, 0, 600, 500);
        
        noStroke();
        fill(0);
        textSize(12);
        text("100", 100, 30);
        text("200", 200, 30);
        text("300", 300, 30);
        text("400", 400, 30);
        text("500", 500, 30);
        text("600", 600, 30);
        pop();
    }

}

